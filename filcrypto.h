/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_FILCRYPTO__
#define __RUST_FILCRYPTO__

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdint.h>

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum FvmError
#else
typedef int32_t FvmError_t; enum
#endif
{
    /** \brief
     *  The error code returned by cgo if the blockstore handle isn't valid.
     */
    FVM_ERROR_INVALID_HANDLE = -1,
    /** \brief
     *  The error code returned by cgo when the block isn't found.
     */
    FVM_ERROR_NOT_FOUND = -2,
    /** \brief
     *  The error code returned by cgo when there's some underlying system error.
     */
    FVM_ERROR_IO = -3,
    /** \brief
     *  The error code returned by cgo when an argument is invalid.
     */
    FVM_ERROR_INVALID_ARGUMENT = -4,
    /** \brief
     *  The error code returned by cgo when the application panics.
     */
    FVM_ERROR_PANIC = -5,
}
#ifdef DOXYGEN
FvmError_t
#endif
;

void dummy (
    FvmError_t _error);

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum FCPResponseStatus
#else
typedef int32_t FCPResponseStatus_t; enum
#endif
{
    /** . */
    F_C_P_RESPONSE_STATUS_NO_ERROR = 0,
    /** . */
    F_C_P_RESPONSE_STATUS_UNCLASSIFIED_ERROR = 1,
    /** . */
    F_C_P_RESPONSE_STATUS_CALLER_ERROR = 2,
    /** . */
    F_C_P_RESPONSE_STATUS_RECEIVER_ERROR = 3,
}
#ifdef DOXYGEN
FCPResponseStatus_t
#endif
;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_uint8 {

    uint8_t * ptr;

    size_t len;

} slice_boxed_uint8_t;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_slice_boxed_uint8 {

    slice_boxed_uint8_t * ptr;

    size_t len;

} slice_boxed_slice_boxed_uint8_t;

typedef struct Result_slice_boxed_slice_boxed_uint8 {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    slice_boxed_slice_boxed_uint8_t value;

} Result_slice_boxed_slice_boxed_uint8_t;

/** \brief
 *  Returns an array of strings containing the device names that can be used.
 */
Result_slice_boxed_slice_boxed_uint8_t * get_gpu_devices (void);

typedef struct Result_void {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

} Result_void_t;

/** \brief
 *  Initializes the logger with a file descriptor where logs will be logged into.
 *
 *  This is usually a pipe that was opened on the receiving side of the logs. The logger is
 *  initialized on the invocation, subsequent calls won't have any effect.
 *
 *  This function must be called right at the start, before any other call. Else the logger will
 *  be initializes implicitely and log to stderr.
 */
Result_void_t * init_log_fd (
    int32_t log_fd);

void destroy_gpu_device_response (
    Result_slice_boxed_slice_boxed_uint8_t * ptr);

void destroy_init_log_fd_response (
    Result_void_t * ptr);

typedef struct { uint8_t idx[96]; } uint8_96_array_t;

void destroy_box_bls_digest (
    uint8_96_array_t * ptr);

typedef struct { uint8_t idx[32]; } uint8_32_array_t;

void destroy_box_bls_private_key (
    uint8_32_array_t * ptr);

typedef struct { uint8_t idx[48]; } uint8_48_array_t;

void destroy_box_bls_public_key (
    uint8_48_array_t * ptr);

void destroy_box_bls_signature (
    uint8_96_array_t * ptr);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

/** \brief
 *  Compute the digest of a message
 *
 *  # Arguments
 *
 *  * `message` - reference to a message byte array
 */
uint8_96_array_t * hash (
    slice_ref_uint8_t message);

/** \brief
 *  Aggregate signatures together into a new signature
 *
 *  # Arguments
 *
 *  * `flattened_signatures` - byte array containing signatures
 *
 *  Returns `None` on error. Result must be freed using `destroy_aggregate_response`.
 */
uint8_96_array_t * aggregate (
    slice_ref_uint8_t flattened_signatures);


#include <stdbool.h>

/** \brief
 *  Verify that a signature is the aggregated signature of hashes - pubkeys
 *
 *  # Arguments
 *
 *  * `signature`             - signature byte array (SIGNATURE_BYTES long)
 *  * `flattened_digests`     - byte array containing digests
 *  * `flattened_public_keys` - byte array containing public keys
 */
bool verify (
    slice_ref_uint8_t signature,
    slice_ref_uint8_t flattened_digests,
    slice_ref_uint8_t flattened_public_keys);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_size {

    size_t const * ptr;

    size_t len;

} slice_ref_size_t;

/** \brief
 *  Verify that a signature is the aggregated signature of the hashed messages
 *
 *  # Arguments
 *
 *  * `signature`             - signature byte array (SIGNATURE_BYTES long)
 *  * `messages`              - array containing the pointers to the messages
 *  * `messages_sizes`        - array containing the lengths of the messages
 *  * `messages_len`          - length of the two messages arrays
 *  * `flattened_public_keys` - byte array containing public keys
 */
bool hash_verify (
    slice_ref_uint8_t signature,
    slice_ref_uint8_t flattened_messages,
    slice_ref_size_t message_sizes,
    slice_ref_uint8_t flattened_public_keys);

/** \brief
 *  Generate a new private key
 */
uint8_32_array_t * private_key_generate (void);

/** \brief
 *  Generate a new private key with seed
 *
 *  **Warning**: Use this function only for testing or with very secure seeds
 *
 *  # Arguments
 *
 *  * `raw_seed` - a seed byte array with 32 bytes
 */
uint8_32_array_t * private_key_generate_with_seed (
    uint8_32_array_t const * raw_seed);

/** \brief
 *  Sign a message with a private key and return the signature
 *
 *  # Arguments
 *
 *  * `raw_private_key` - private key byte array
 *  * `message` - message byte array
 *
 *  Returns `None` when passed invalid arguments.
 */
uint8_96_array_t * private_key_sign (
    slice_ref_uint8_t raw_private_key,
    slice_ref_uint8_t message);

/** \brief
 *  Generate the public key for a private key
 *
 *  # Arguments
 *
 *  * `raw_private_key` - private key byte array
 *
 *  Returns `None` when passed invalid arguments.
 */
uint8_48_array_t * private_key_public_key (
    slice_ref_uint8_t raw_private_key);

/** \brief
 *  Returns a zero signature, used as placeholder in Filecoin.
 *
 *  The return value is a pointer to a compressed signature in bytes, of length `SIGNATURE_BYTES`
 */
uint8_96_array_t * create_zero_signature (void);

/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum FvmRegisteredVersion
#else
typedef uint8_t FvmRegisteredVersion_t; enum
#endif
{
    /** . */
    FVM_REGISTERED_VERSION_V1,
}
#ifdef DOXYGEN
FvmRegisteredVersion_t
#endif
;

typedef struct InnerFvmMachine InnerFvmMachine_t;

typedef struct Result_InnerFvmMachine_ptr {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    InnerFvmMachine_t * value;

} Result_InnerFvmMachine_ptr_t;

/** \brief
 *  Note: the incoming args as u64 and odd conversions to i32/i64
 *  for some types is due to the generated bindings not liking the
 *  32bit types as incoming args
 *
 */
Result_InnerFvmMachine_ptr_t * create_fvm_machine (
    FvmRegisteredVersion_t fvm_version,
    uint64_t chain_epoch,
    uint64_t chain_timestamp,
    uint64_t chain_id,
    uint64_t base_fee_hi,
    uint64_t base_fee_lo,
    uint64_t circulating_supply_hi,
    uint64_t circulating_supply_lo,
    uint32_t network_version,
    slice_ref_uint8_t state_root,
    bool tracing,
    uint64_t blockstore_id,
    uint64_t externs_id);

Result_InnerFvmMachine_ptr_t * create_fvm_debug_machine (
    FvmRegisteredVersion_t fvm_version,
    uint64_t chain_epoch,
    uint64_t chain_timestamp,
    uint64_t chain_id,
    uint64_t base_fee_hi,
    uint64_t base_fee_lo,
    uint64_t circulating_supply_hi,
    uint64_t circulating_supply_lo,
    uint32_t network_version,
    slice_ref_uint8_t state_root,
    slice_ref_uint8_t actor_redirect,
    bool tracing,
    uint64_t blockstore_id,
    uint64_t externs_id);

typedef struct FvmMachineExecuteResponse {

    uint64_t exit_code;

    slice_boxed_uint8_t return_val;

    uint64_t gas_used;

    uint64_t penalty_hi;

    uint64_t penalty_lo;

    uint64_t miner_tip_hi;

    uint64_t miner_tip_lo;

    uint64_t base_fee_burn_hi;

    uint64_t base_fee_burn_lo;

    uint64_t over_estimation_burn_hi;

    uint64_t over_estimation_burn_lo;

    uint64_t refund_hi;

    uint64_t refund_lo;

    uint64_t gas_refund;

    uint64_t gas_burned;

    slice_boxed_uint8_t exec_trace;

    slice_boxed_uint8_t failure_info;

    slice_boxed_uint8_t events;

    slice_boxed_uint8_t events_root;

} FvmMachineExecuteResponse_t;

typedef struct Result_FvmMachineExecuteResponse {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    FvmMachineExecuteResponse_t value;

} Result_FvmMachineExecuteResponse_t;

Result_FvmMachineExecuteResponse_t * fvm_machine_execute_message (
    InnerFvmMachine_t const * executor,
    slice_ref_uint8_t message,
    uint64_t chain_len,
    uint64_t apply_kind);

typedef struct Result_slice_boxed_uint8 {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    slice_boxed_uint8_t value;

} Result_slice_boxed_uint8_t;

Result_slice_boxed_uint8_t * fvm_machine_flush (
    InnerFvmMachine_t const * executor);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void drop_fvm_machine (
    InnerFvmMachine_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_create_fvm_machine_response (
    Result_InnerFvmMachine_ptr_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_fvm_machine_execute_response (
    Result_FvmMachineExecuteResponse_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_fvm_machine_flush_response (
    Result_slice_boxed_uint8_t * ptr);

slice_boxed_uint8_t alloc_boxed_slice (
    size_t size);

void destroy_boxed_slice (
    slice_boxed_uint8_t ptr);

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum RegisteredSealProof
#else
typedef int32_t RegisteredSealProof_t; enum
#endif
{
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG2_KI_B_V1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG8_MI_B_V1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG512_MI_B_V1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG32_GI_B_V1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG64_GI_B_V1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG2_KI_B_V1_1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG8_MI_B_V1_1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG512_MI_B_V1_1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG32_GI_B_V1_1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG64_GI_B_V1_1,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG2_KI_B_V1_1__FEAT__SYNTHETIC_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG8_MI_B_V1_1__FEAT__SYNTHETIC_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG512_MI_B_V1_1__FEAT__SYNTHETIC_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG32_GI_B_V1_1__FEAT__SYNTHETIC_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG64_GI_B_V1_1__FEAT__SYNTHETIC_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG2_KI_B_V1_2__FEAT__NON_INTERACTIVE_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG8_MI_B_V1_2__FEAT__NON_INTERACTIVE_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG512_MI_B_V1_2__FEAT__NON_INTERACTIVE_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG32_GI_B_V1_2__FEAT__NON_INTERACTIVE_PO_REP,
    /** . */
    REGISTERED_SEAL_PROOF_STACKED_DRG64_GI_B_V1_2__FEAT__NON_INTERACTIVE_PO_REP,
}
#ifdef DOXYGEN
RegisteredSealProof_t
#endif
;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint64 {

    uint64_t const * ptr;

    size_t len;

} slice_ref_uint64_t;

typedef struct WriteWithAlignment {

    uint8_32_array_t comm_p;

    uint64_t left_alignment_unpadded;

    uint64_t total_write_unpadded;

} WriteWithAlignment_t;

typedef struct Result_WriteWithAlignment {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    WriteWithAlignment_t value;

} Result_WriteWithAlignment_t;

/** \brief
 *  TODO: document
 */
Result_WriteWithAlignment_t * write_with_alignment (
    RegisteredSealProof_t registered_proof,
    int32_t src_fd,
    uint64_t src_size,
    int32_t dst_fd,
    slice_ref_uint64_t existing_piece_sizes);

typedef struct WriteWithoutAlignment {

    uint8_32_array_t comm_p;

    uint64_t total_write_unpadded;

} WriteWithoutAlignment_t;

typedef struct Result_WriteWithoutAlignment {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    WriteWithoutAlignment_t value;

} Result_WriteWithoutAlignment_t;

/** \brief
 *  TODO: document
 */
Result_WriteWithoutAlignment_t * write_without_alignment (
    RegisteredSealProof_t registered_proof,
    int32_t src_fd,
    uint64_t src_size,
    int32_t dst_fd);

typedef struct Result_uint8_32_array {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    uint8_32_array_t value;

} Result_uint8_32_array_t;

Result_uint8_32_array_t * fauxrep (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t sealed_sector_path);

Result_uint8_32_array_t * fauxrep2 (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t existing_p_aux_path);

typedef struct PublicPieceInfo {

    uint64_t num_bytes;

    uint8_32_array_t comm_p;

} PublicPieceInfo_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_PublicPieceInfo {

    PublicPieceInfo_t const * ptr;

    size_t len;

} slice_ref_PublicPieceInfo_t;

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint8_t * seal_pre_commit_phase1 (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t staged_sector_path,
    slice_ref_uint8_t sealed_sector_path,
    uint64_t sector_id,
    uint8_32_array_t const * prover_id,
    uint8_32_array_t const * ticket,
    slice_ref_PublicPieceInfo_t pieces);

/** \brief
 *  Runs the SDR process the same way as it would during PreCommit Phase 1.
 *
 *  The `output_dir` is the directory where the layer labels are stored. The `replica_id` is needed
 *  to make sure the output is unique.
 */
Result_void_t * generate_sdr (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t output_dir,
    uint8_32_array_t const * replica_id);

typedef struct SealPreCommitPhase2 {

    RegisteredSealProof_t registered_proof;

    uint8_32_array_t comm_d;

    uint8_32_array_t comm_r;

} SealPreCommitPhase2_t;

typedef struct Result_SealPreCommitPhase2 {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    SealPreCommitPhase2_t value;

} Result_SealPreCommitPhase2_t;

/** \brief
 *  TODO: document
 */
Result_SealPreCommitPhase2_t * seal_pre_commit_phase2 (
    slice_ref_uint8_t seal_pre_commit_phase1_output,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t sealed_sector_path);

/** \brief
 *  Generates a TreeRLast the same way as during PreCommit Phase 2 and return the CommRLast.
 *
 *  The `replica_path` points to the sealed file. `output_dir` is where the TreeRLast should be
 *  stored. It's a directory as it may consist of serveral files.
 */
Result_uint8_32_array_t * generate_tree_r_last (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t replica_path,
    slice_ref_uint8_t output_dir);

/** \brief
 *  Generates a TreeC the same way as during PreCommit Phase 2 and returns the CommC.
 *
 *  The `input_dir` is the directory where the label layers are stored, which were constructed
 *  during the SDR process (PreCommit Phase 1). No other data is needed.
 *  The `output_dir` is the directory where the resulting TreeC tree is stored (it may be split
 *  into several files).
 *  The `input_dir` and `output_dir` may point to the same directory. Usually that's the "cache
 *  directory".
 */
Result_uint8_32_array_t * generate_tree_c (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t input_dir,
    slice_ref_uint8_t output_dir);

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint8_t * seal_commit_phase1 (
    RegisteredSealProof_t registered_proof,
    uint8_32_array_t const * comm_r,
    uint8_32_array_t const * comm_d,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t replica_path,
    uint64_t sector_id,
    uint8_32_array_t const * prover_id,
    uint8_32_array_t const * ticket,
    uint8_32_array_t const * seed,
    slice_ref_PublicPieceInfo_t pieces);

Result_slice_boxed_uint8_t * seal_commit_phase2 (
    slice_ref_uint8_t seal_commit_phase1_output,
    uint64_t sector_id,
    uint8_32_array_t const * prover_id);

/** \brief
 *  This function generates a variant of the circuit proof for the second phase of the sealing
 *  process. It takes as input the output from the first phase of the sealing process
 *  [`seal_commit_phase1`] and a sector ID.
 *
 *  This variant of `seal_commit_phase2` is intended specifically for returning the circuit proofs
 *  of a NonInteractivePoRep proof, such that it can later be aggregated with other
 *  NonInteractivePoRep proofs.
 *
 *  # Arguments
 *
 *  * `seal_commit_phase1_output` - A reference to a slice of bytes representing the output from the
 *    first phase of the sealing process.
 *  * `sector_id` - A 64-bit integer representing the sector ID.
 *
 *  # Returns
 *  This function returns a `SealCommitPhase2Response` wrapped in a `repr_c::Box`. This response
 *  includes the proof generated in this phase of the sealing process.
 */
Result_slice_boxed_uint8_t * seal_commit_phase2_circuit_proofs (
    slice_ref_uint8_t seal_commit_phase1_output,
    uint64_t sector_id);

/** \brief
 *  TODO: document
 */
Result_void_t * generate_synth_proofs (
    RegisteredSealProof_t registered_proof,
    uint8_32_array_t const * comm_r,
    uint8_32_array_t const * comm_d,
    slice_ref_uint8_t cache_dir_path,
    slice_ref_uint8_t replica_path,
    uint64_t sector_id,
    uint8_32_array_t const * prover_id,
    uint8_32_array_t const * ticket,
    slice_ref_PublicPieceInfo_t pieces);

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum RegisteredAggregationProof
#else
typedef int32_t RegisteredAggregationProof_t; enum
#endif
{
    /** . */
    REGISTERED_AGGREGATION_PROOF_SNARK_PACK_V1,
    /** . */
    REGISTERED_AGGREGATION_PROOF_SNARK_PACK_V2,
}
#ifdef DOXYGEN
RegisteredAggregationProof_t
#endif
;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8_32_array {

    uint8_32_array_t const * ptr;

    size_t len;

} slice_ref_uint8_32_array_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_slice_boxed_uint8 {

    slice_boxed_uint8_t const * ptr;

    size_t len;

} slice_ref_slice_boxed_uint8_t;

Result_slice_boxed_uint8_t * aggregate_seal_proofs (
    RegisteredSealProof_t registered_proof,
    RegisteredAggregationProof_t registered_aggregation,
    slice_ref_uint8_32_array_t comm_rs,
    slice_ref_uint8_32_array_t seeds,
    slice_ref_slice_boxed_uint8_t seal_commit_responses);

typedef struct AggregationInputs {

    uint8_32_array_t comm_r;

    uint8_32_array_t comm_d;

    uint64_t sector_id;

    uint8_32_array_t ticket;

    uint8_32_array_t seed;

} AggregationInputs_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_AggregationInputs {

    AggregationInputs_t const * ptr;

    size_t len;

} slice_ref_AggregationInputs_t;

typedef struct Result_bool {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    bool value;

} Result_bool_t;

/** \brief
 *  Verifies the output of an aggregated seal.
 */
Result_bool_t * verify_aggregate_seal_proof (
    RegisteredSealProof_t registered_proof,
    RegisteredAggregationProof_t registered_aggregation,
    uint8_32_array_t const * prover_id,
    slice_ref_uint8_t proof,
    slice_ref_AggregationInputs_t commit_inputs);

/** \brief
 *  TODO: document
 */
Result_void_t * unseal_range (
    RegisteredSealProof_t registered_proof,
    slice_ref_uint8_t cache_dir_path,
    int32_t sealed_sector_fd_raw,
    int32_t unseal_output_fd_raw,
    uint64_t sector_id,
    uint8_32_array_t const * prover_id,
    uint8_32_array_t const * ticket,
    uint8_32_array_t const * comm_d,
    uint64_t unpadded_byte_index,
    uint64_t unpadded_bytes_amount);

/** \brief
 *  Verifies the output of seal.
 */
Result_bool_t * verify_seal (
    RegisteredSealProof_t registered_proof,
    uint8_32_array_t const * comm_r,
    uint8_32_array_t const * comm_d,
    uint8_32_array_t const * prover_id,
    uint8_32_array_t const * ticket,
    uint8_32_array_t const * seed,
    uint64_t sector_id,
    slice_ref_uint8_t proof);

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum RegisteredPoStProof
#else
typedef int32_t RegisteredPoStProof_t; enum
#endif
{
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINNING2_KI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINNING8_MI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINNING512_MI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINNING32_GI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINNING64_GI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW2_KI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW8_MI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW512_MI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW32_GI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW64_GI_B_V1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW2_KI_B_V1_1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW8_MI_B_V1_1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW512_MI_B_V1_1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW32_GI_B_V1_1,
    /** . */
    REGISTERED_PO_ST_PROOF_STACKED_DRG_WINDOW64_GI_B_V1_1,
}
#ifdef DOXYGEN
RegisteredPoStProof_t
#endif
;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_uint64 {

    uint64_t * ptr;

    size_t len;

} slice_boxed_uint64_t;

typedef struct Result_slice_boxed_uint64 {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    slice_boxed_uint64_t value;

} Result_slice_boxed_uint64_t;

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint64_t * generate_winning_post_sector_challenge (
    RegisteredPoStProof_t registered_proof,
    uint8_32_array_t const * randomness,
    uint64_t sector_set_len,
    uint8_32_array_t const * prover_id);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_slice_boxed_uint64 {

    slice_boxed_uint64_t * ptr;

    size_t len;

} slice_boxed_slice_boxed_uint64_t;

typedef struct GenerateFallbackSectorChallenges {

    slice_boxed_uint64_t ids;

    slice_boxed_slice_boxed_uint64_t challenges;

} GenerateFallbackSectorChallenges_t;

typedef struct Result_GenerateFallbackSectorChallenges {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    GenerateFallbackSectorChallenges_t value;

} Result_GenerateFallbackSectorChallenges_t;

/** \brief
 *  TODO: document
 */
Result_GenerateFallbackSectorChallenges_t * generate_fallback_sector_challenges (
    RegisteredPoStProof_t registered_proof,
    uint8_32_array_t const * randomness,
    slice_ref_uint64_t sector_ids,
    uint8_32_array_t const * prover_id);

typedef struct PrivateReplicaInfo {

    RegisteredPoStProof_t registered_proof;

    slice_boxed_uint8_t cache_dir_path;

    uint8_32_array_t comm_r;

    slice_boxed_uint8_t replica_path;

    uint64_t sector_id;

} PrivateReplicaInfo_t;

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint8_t * generate_single_vanilla_proof (
    PrivateReplicaInfo_t replica,
    slice_ref_uint64_t challenges);

typedef struct PoStProof {

    RegisteredPoStProof_t registered_proof;

    slice_boxed_uint8_t proof;

} PoStProof_t;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_PoStProof {

    PoStProof_t * ptr;

    size_t len;

} slice_boxed_PoStProof_t;

typedef struct Result_slice_boxed_PoStProof {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    slice_boxed_PoStProof_t value;

} Result_slice_boxed_PoStProof_t;

/** \brief
 *  TODO: document
 */
Result_slice_boxed_PoStProof_t * generate_winning_post_with_vanilla (
    RegisteredPoStProof_t registered_proof,
    uint8_32_array_t const * randomness,
    uint8_32_array_t const * prover_id,
    slice_ref_slice_boxed_uint8_t vanilla_proofs);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_PrivateReplicaInfo {

    PrivateReplicaInfo_t const * ptr;

    size_t len;

} slice_ref_PrivateReplicaInfo_t;

/** \brief
 *  TODO: document
 */
Result_slice_boxed_PoStProof_t * generate_winning_post (
    uint8_32_array_t const * randomness,
    slice_ref_PrivateReplicaInfo_t replicas,
    uint8_32_array_t const * prover_id);

typedef struct PublicReplicaInfo {

    RegisteredPoStProof_t registered_proof;

    uint8_32_array_t comm_r;

    uint64_t sector_id;

} PublicReplicaInfo_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_PublicReplicaInfo {

    PublicReplicaInfo_t const * ptr;

    size_t len;

} slice_ref_PublicReplicaInfo_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_PoStProof {

    PoStProof_t const * ptr;

    size_t len;

} slice_ref_PoStProof_t;

/** \brief
 *  Verifies that a proof-of-spacetime is valid.
 */
Result_bool_t * verify_winning_post (
    uint8_32_array_t const * randomness,
    slice_ref_PublicReplicaInfo_t replicas,
    slice_ref_PoStProof_t proofs,
    uint8_32_array_t const * prover_id);

typedef struct GenerateWindowPoSt {

    slice_boxed_PoStProof_t proofs;

    slice_boxed_uint64_t faulty_sectors;

} GenerateWindowPoSt_t;

typedef struct Result_GenerateWindowPoSt {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    GenerateWindowPoSt_t value;

} Result_GenerateWindowPoSt_t;

/** \brief
 *  TODO: document
 */
Result_GenerateWindowPoSt_t * generate_window_post_with_vanilla (
    RegisteredPoStProof_t registered_proof,
    uint8_32_array_t const * randomness,
    uint8_32_array_t const * prover_id,
    slice_ref_slice_boxed_uint8_t vanilla_proofs);

/** \brief
 *  TODO: document
 */
Result_GenerateWindowPoSt_t * generate_window_post (
    uint8_32_array_t const * randomness,
    slice_ref_PrivateReplicaInfo_t replicas,
    uint8_32_array_t const * prover_id);

/** \brief
 *  Verifies that a proof-of-spacetime is valid.
 */
Result_bool_t * verify_window_post (
    uint8_32_array_t const * randomness,
    slice_ref_PublicReplicaInfo_t replicas,
    slice_ref_PoStProof_t proofs,
    uint8_32_array_t const * prover_id);

typedef struct Result_PoStProof {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    PoStProof_t value;

} Result_PoStProof_t;

/** \brief
 *  TODO: document
 */
Result_PoStProof_t * merge_window_post_partition_proofs (
    RegisteredPoStProof_t registered_proof,
    slice_ref_slice_boxed_uint8_t partition_proofs);

typedef struct Result_size {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    size_t value;

} Result_size_t;

/** \brief
 *  TODO: document
 */
Result_size_t * get_num_partition_for_fallback_post (
    RegisteredPoStProof_t registered_proof,
    size_t num_sectors);

typedef struct PartitionSnarkProof {

    RegisteredPoStProof_t registered_proof;

    slice_boxed_uint8_t proof;

} PartitionSnarkProof_t;

typedef struct GenerateSingleWindowPoStWithVanilla {

    PartitionSnarkProof_t partition_proof;

    slice_boxed_uint64_t faulty_sectors;

} GenerateSingleWindowPoStWithVanilla_t;

typedef struct Result_GenerateSingleWindowPoStWithVanilla {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    GenerateSingleWindowPoStWithVanilla_t value;

} Result_GenerateSingleWindowPoStWithVanilla_t;

/** \brief
 *  TODO: document
 */
Result_GenerateSingleWindowPoStWithVanilla_t * generate_single_window_post_with_vanilla (
    RegisteredPoStProof_t registered_proof,
    uint8_32_array_t const * randomness,
    uint8_32_array_t const * prover_id,
    slice_ref_slice_boxed_uint8_t vanilla_proofs,
    size_t partition_index);

/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef enum RegisteredUpdateProof
#else
typedef int32_t RegisteredUpdateProof_t; enum
#endif
{
    /** . */
    REGISTERED_UPDATE_PROOF_STACKED_DRG2_KI_B_V1,
    /** . */
    REGISTERED_UPDATE_PROOF_STACKED_DRG8_MI_B_V1,
    /** . */
    REGISTERED_UPDATE_PROOF_STACKED_DRG512_MI_B_V1,
    /** . */
    REGISTERED_UPDATE_PROOF_STACKED_DRG32_GI_B_V1,
    /** . */
    REGISTERED_UPDATE_PROOF_STACKED_DRG64_GI_B_V1,
}
#ifdef DOXYGEN
RegisteredUpdateProof_t
#endif
;

typedef struct EmptySectorUpdateEncodeInto {

    uint8_32_array_t comm_r_new;

    uint8_32_array_t comm_r_last_new;

    uint8_32_array_t comm_d_new;

} EmptySectorUpdateEncodeInto_t;

typedef struct Result_EmptySectorUpdateEncodeInto {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    EmptySectorUpdateEncodeInto_t value;

} Result_EmptySectorUpdateEncodeInto_t;

/** \brief
 *  TODO: document
 */
Result_EmptySectorUpdateEncodeInto_t * empty_sector_update_encode_into (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_uint8_t new_replica_path,
    slice_ref_uint8_t new_cache_dir_path,
    slice_ref_uint8_t sector_key_path,
    slice_ref_uint8_t sector_key_cache_dir_path,
    slice_ref_uint8_t staged_data_path,
    slice_ref_PublicPieceInfo_t pieces);

/** \brief
 *  TODO: document
 */
Result_void_t * empty_sector_update_decode_from (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_uint8_t out_data_path,
    slice_ref_uint8_t replica_path,
    slice_ref_uint8_t sector_key_path,
    slice_ref_uint8_t sector_key_cache_dir_path,
    uint8_32_array_t const * comm_d_new);

/** \brief
 *  Decodes data from an empty sector upgraded replica (aka SnapDeals)
 *
 *  This function is similar to [`empty_sector_update_decode_from`], the difference is that it
 *  operates directly on the given file descriptions. The current position of the file descriptors
 *  is where the decoding starts, i.e. you need to seek to the intended offset before you call this
 *  funtion.
 *
 *  `nodes_count` is the total number the input file contains. It's the sector size in bytes
 *  divided by the field element size of 32 bytes.
 *
 *  `comm_d` is the commitment of the data that that was "snapped" into the sector. `comm_r` is
 *  the commitment of the sealed empty sector, before data was "snapped" into it.
 *
 *  `input_data` is a file descriptor of the data you want to decode from, the "snapped" sector.
 *  `sector_key_data` is a file descriptor that points to the sealed empty sector before it was
 *  "snapped" into. `output_data` is the file descriptor the decoded data should be written into.
 *
 *  `nodes_offset` is the offset relative to the beginning of the file, it's again in field
 *  elements and not in bytes. So if the `input_data` file descriptor was sought to a certain
 *  position, it's that offset. `nodes_offset` is about how many nodes should be decoded.
 */
Result_void_t * empty_sector_update_decode_from_range (
    RegisteredUpdateProof_t registered_proof,
    uint8_32_array_t const * comm_d,
    uint8_32_array_t const * comm_r,
    int32_t input_fd,
    int32_t sector_key_fd,
    int32_t output_fd,
    uint64_t nodes_offset,
    uint64_t num_nodes);

/** \brief
 *  TODO: document
 */
Result_void_t * empty_sector_update_remove_encoded_data (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_uint8_t sector_key_path,
    slice_ref_uint8_t sector_key_cache_dir_path,
    slice_ref_uint8_t replica_path,
    slice_ref_uint8_t replica_cache_path,
    slice_ref_uint8_t data_path,
    uint8_32_array_t const * comm_d_new);

/** \brief
 *  TODO: document
 */
Result_slice_boxed_slice_boxed_uint8_t * generate_empty_sector_update_partition_proofs (
    RegisteredUpdateProof_t registered_proof,
    uint8_32_array_t const * comm_r_old,
    uint8_32_array_t const * comm_r_new,
    uint8_32_array_t const * comm_d_new,
    slice_ref_uint8_t sector_key_path,
    slice_ref_uint8_t sector_key_cache_dir_path,
    slice_ref_uint8_t replica_path,
    slice_ref_uint8_t replica_cache_path);

/** \brief
 *  TODO: document
 */
Result_bool_t * verify_empty_sector_update_partition_proofs (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_slice_boxed_uint8_t proofs,
    uint8_32_array_t const * comm_r_old,
    uint8_32_array_t const * comm_r_new,
    uint8_32_array_t const * comm_d_new);

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint8_t * generate_empty_sector_update_proof_with_vanilla (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_slice_boxed_uint8_t vanilla_proofs,
    uint8_32_array_t const * comm_r_old,
    uint8_32_array_t const * comm_r_new,
    uint8_32_array_t const * comm_d_new);

/** \brief
 *  TODO: document
 */
Result_slice_boxed_uint8_t * generate_empty_sector_update_proof (
    RegisteredUpdateProof_t registered_proof,
    uint8_32_array_t const * comm_r_old,
    uint8_32_array_t const * comm_r_new,
    uint8_32_array_t const * comm_d_new,
    slice_ref_uint8_t sector_key_path,
    slice_ref_uint8_t sector_key_cache_dir_path,
    slice_ref_uint8_t replica_path,
    slice_ref_uint8_t replica_cache_path);

/** \brief
 *  TODO: document
 */
Result_bool_t * verify_empty_sector_update_proof (
    RegisteredUpdateProof_t registered_proof,
    slice_ref_uint8_t proof,
    uint8_32_array_t const * comm_r_old,
    uint8_32_array_t const * comm_r_new,
    uint8_32_array_t const * comm_d_new);

typedef struct GeneratePieceCommitment {

    uint8_32_array_t comm_p;

    uint64_t num_bytes_aligned;

} GeneratePieceCommitment_t;

typedef struct Result_GeneratePieceCommitment {

    FCPResponseStatus_t status_code;

    slice_boxed_uint8_t error_msg;

    GeneratePieceCommitment_t value;

} Result_GeneratePieceCommitment_t;

/** \brief
 *  Returns the merkle root for a piece after piece padding and alignment.
 *  The caller is responsible for closing the passed in file descriptor.
 */
Result_GeneratePieceCommitment_t * generate_piece_commitment (
    RegisteredSealProof_t registered_proof,
    int32_t piece_fd_raw,
    uint64_t unpadded_piece_size);

/** \brief
 *  Returns the merkle root for a sector containing the provided pieces.
 */
Result_uint8_32_array_t * generate_data_commitment (
    RegisteredSealProof_t registered_proof,
    slice_ref_PublicPieceInfo_t pieces);

Result_void_t * clear_cache (
    uint64_t sector_size,
    slice_ref_uint8_t cache_dir_path);

Result_void_t * clear_synthetic_proofs (
    uint64_t sector_size,
    slice_ref_uint8_t cache_dir_path);

/** \brief
 *  Returns the number of user bytes that will fit into a staged sector.
 */
uint64_t get_max_user_bytes_per_staged_sector (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the CID of the Groth parameter file for sealing.
 */
Result_slice_boxed_uint8_t * get_seal_params_cid (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the CID of the verifying key-file for verifying a seal proof.
 */
Result_slice_boxed_uint8_t * get_seal_verifying_key_cid (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the path from which the proofs library expects to find the Groth
 *  parameter file used when sealing.
 */
Result_slice_boxed_uint8_t * get_seal_params_path (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the path from which the proofs library expects to find the verifying
 *  key-file used when verifying a seal proof.
 */
Result_slice_boxed_uint8_t * get_seal_verifying_key_path (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the identity of the circuit for the provided seal proof.
 */
Result_slice_boxed_uint8_t * get_seal_circuit_identifier (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the version of the provided seal proof type.
 */
Result_slice_boxed_uint8_t * get_seal_version (
    RegisteredSealProof_t registered_proof);

/** \brief
 *  Returns the CID of the Groth parameter file for generating a PoSt.
 */
Result_slice_boxed_uint8_t * get_post_params_cid (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Returns the CID of the verifying key-file for verifying a PoSt proof.
 */
Result_slice_boxed_uint8_t * get_post_verifying_key_cid (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Returns the path from which the proofs library expects to find the Groth
 *  parameter file used when generating a PoSt.
 */
Result_slice_boxed_uint8_t * get_post_params_path (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Returns the path from which the proofs library expects to find the verifying
 *  key-file used when verifying a PoSt proof.
 */
Result_slice_boxed_uint8_t * get_post_verifying_key_path (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Returns the identity of the circuit for the provided PoSt proof type.
 */
Result_slice_boxed_uint8_t * get_post_circuit_identifier (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Returns the version of the provided seal proof.
 */
Result_slice_boxed_uint8_t * get_post_version (
    RegisteredPoStProof_t registered_proof);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_write_with_alignment_response (
    Result_WriteWithAlignment_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_write_without_alignment_response (
    Result_WriteWithoutAlignment_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_fauxrep_response (
    Result_uint8_32_array_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_seal_pre_commit_phase1_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_sdr_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_seal_pre_commit_phase2_response (
    Result_SealPreCommitPhase2_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_tree_r_last_response (
    Result_uint8_32_array_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_tree_c_response (
    Result_uint8_32_array_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_seal_commit_phase1_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_seal_commit_phase2_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_unseal_range_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_piece_commitment_response (
    Result_GeneratePieceCommitment_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_data_commitment_response (
    Result_uint8_32_array_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_string_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_verify_seal_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_verify_aggregate_seal_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_finalize_ticket_response (
    Result_uint8_32_array_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_verify_winning_post_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_verify_window_post_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_fallback_sector_challenges_response (
    Result_GenerateFallbackSectorChallenges_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_single_vanilla_proof_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_single_window_post_with_vanilla_response (
    Result_GenerateSingleWindowPoStWithVanilla_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_get_num_partition_for_fallback_post_response (
    Result_size_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_merge_window_post_partition_proofs_response (
    Result_PoStProof_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_winning_post_response (
    Result_slice_boxed_PoStProof_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_window_post_response (
    Result_GenerateWindowPoSt_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_winning_post_sector_challenge (
    Result_slice_boxed_uint64_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_synth_proofs_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_clear_cache_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_aggregate_proof (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_generate_proof_response (
    Result_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_verify_proof_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_generate_empty_sector_update_partition_proof_response (
    Result_slice_boxed_slice_boxed_uint8_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_verify_empty_sector_update_partition_proof_response (
    Result_bool_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_encode_into_response (
    Result_EmptySectorUpdateEncodeInto_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_decode_from_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_decode_from_range_response (
    Result_void_t * ptr);

/** \brief
 *  Destroys the passed in `repr_c::Box<$type>`.
 */
void destroy_empty_sector_update_remove_encoded_data_response (
    Result_void_t * ptr);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_FILCRYPTO__ */
